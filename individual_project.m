% Individual project

%% 1.0 Functions
function fig = plotPopulationHistory(populationLocations, crossover)
    fig = figure;
    hold on;
    numGenerations = length(populationLocations);
    baseColor = [0.6 0.8 1.0];
    for gen = 1:numGenerations
        pop = populationLocations{gen};
        alpha = 1 - 0.7 * (gen - 1) / (numGenerations - 1);
        color = baseColor * alpha;
        scatter(pop(:,1), pop(:,2), 30, color, 'filled', 'MarkerFaceAlpha', 0.5);
    end
    xlabel('X Position');
    ylabel('Y Position');
    crossover_trunc = floor(crossover * 100) / 100;
    title(['Population Locations, ', num2str(crossover_trunc)]);
    axis equal;
    grid on;
end

function z = rastriginsfcn(x)
    % Rastrigin function for 2D input
    % Accepts [NÃ—2] input matrix
    A = 10;
    z = A * size(x, 2) + sum(x.^2 - A * cos(2 * pi * x), 2);
end

function z = ps_example(x)
    % Simple test function with 2D input
    z = (x(:,1) + 2*x(:,2) - 7).^2 + (2*x(:,1) + x(:,2) - 5).^2;
end

%% 1.1. Black-box optimization
clear
clc
close all

% Reproducibility
rng default

% Plot Rastrigin
figure
fsurf(@(x,y) reshape(rastriginsfcn([x(:), y(:)]), size(x)), ...
    'MeshDensity', 100, ...
    'ShowContours', 'on', ...
    'LineStyle', ':')
title('Rastrigin Function')
xlabel('x')
ylabel('y')
zlabel('z')
colormap turbo
view(3)

% Plot PS Example
figure
fsurf(@(x,y) reshape(ps_example([x(:), y(:)]), size(x)), ...
    'MeshDensity', 100, ...
    'ShowContours', 'on', ...
    'LineStyle', ':')
title('PS Example Function')
xlabel('x')
ylabel('y')
zlabel('z')
colormap parula
view(3)

% Genetic Algorithm: Crossover fraction
% Simulated Annealing: Rate of Change of temperature

% GA
function [x, fval, elapsed] = GA(fun, crossover_fraction)
    populationHistory = {};
    function [state, options, optchanged] = savePop(options, state, flag)
        optchanged = false;
        if strcmp(flag, 'iter')
            populationHistory{end+1} = state.Population;
        end
    end
    options = optimoptions('ga', ...
        'PlotFcn', {'gaplotbestf','gaplotdistance','gaplotstopping'}, ...
        'OutputFcn', @savePop, ...
        'PopulationSize', 50, ...
        'CrossoverFraction', crossover_fraction);
    t0 = tic;
    [x, fval] = ga(fun, 2, [], [], [], [], [], [], [], options);
    elapsed = toc(t0);
    saveas(gcf, sprintf('plots/one/GA_%s_C%.2f_summary.jpg', func2str(fun), crossover_fraction));
    close(gcf);
    fig = plotPopulationHistory(populationHistory, crossover_fraction);
    saveas(fig, sprintf('plots/one/GA_%s_C%.2f_population.jpg', func2str(fun), crossover_fraction));
    close(fig);
end

function [x, fval, convergence_time] = SA(fun, T)
    x0 = [1 1];
    lb = [-6, -6];
    ub = [6, 6];
    visitedPoints = [];
    visitedValues = [];
    funcname = func2str(fun);

    function [stop, options, optchanged] = saveVisited(options, optimValues, state)
        stop = false;
        optchanged = false;
        switch state
            case 'init'
                visitedPoints = [];
                visitedValues = [];
            case 'iter'
                visitedPoints(end+1, :) = optimValues.x;
                visitedValues(end+1, 1) = optimValues.fval;
            case 'done'
                fig = figure;
                scatter(visitedPoints(:,1), visitedPoints(:,2), 30, visitedValues, 'filled');
                colorbar;
                title(['Function Values, T = ', num2str(floor(T))]);
                xlabel('x');
                ylabel('y');
                axis equal;
                grid on;
                colormap turbo;

                % Save and close custom plot
                filename = sprintf('plots/one/SA_%s_T%d_values.jpg', funcname, floor(T));
                saveas(fig, filename);
                close(fig);
        end
    end

    options = optimoptions(@simulannealbnd, ...
        'InitialTemperature', T, ...
        'TemperatureFcn', 'temperaturefast', ...
        'OutputFcn', @saveVisited, ...
        'PlotFcn', {@saplotbestf, @saplotf});
    
    t0 = tic;
    [x, fval, ~, ~] = simulannealbnd(fun, x0, lb, ub, options);
    convergence_time = toc(t0);

    % Save and close summary plot generated by SA (gcf at this point)
    filename = sprintf('plots/one/SA_%s_T%d_summary.jpg', funcname, floor(T));
    saveas(gcf, filename);
    close(gcf);
end

%% 1.2. Application
clear, clc, close all
N_PTS = 41;

% Parameters
CROSSOVER = linspace(0, 1, N_PTS);
TEMPERATURE = linspace(200, 1000, N_PTS);

% Initialize performance vectors (parameter, function, time and position)
perf_rast_GA = zeros(N_PTS, 5);
perf_rast_SA = zeros(N_PTS, 5);
perf_ps_GA = zeros(N_PTS, 5);
perf_ps_SA = zeros(N_PTS, 5);

% Iterations
for ii = 1:N_PTS
    [x_GA, fval_GA, time_GA] = GA(@rastriginsfcn, CROSSOVER(ii));
    perf_rast_GA(ii, :) = [CROSSOVER(ii), fval_GA, time_GA, x_GA(1), x_GA(2)];
end
for ii = 1:N_PTS
    [x_SA, fval_SA, time_SA] = SA(@rastriginsfcn, TEMPERATURE(ii));
    perf_rast_SA(ii, :) = [TEMPERATURE(ii), fval_SA, time_SA, x_SA(1), x_SA(2)];
end
for ii = 1:N_PTS
    [x_GA, fval_GA, time_GA] = GA(@ps_example, CROSSOVER(ii));
    perf_ps_GA(ii, :) = [CROSSOVER(ii), fval_GA, time_GA, x_GA(1), x_GA(2)];
end
for ii = 1:N_PTS
    [x_SA, fval_SA, time_SA] = SA(@ps_example, TEMPERATURE(ii));
    perf_ps_SA(ii, :) = [TEMPERATURE(ii), fval_SA, time_SA, x_SA(1), x_SA(2)];
end

rast_GA_table = array2table(perf_rast_GA, ...
    'VariableNames', {'Crossover', 'FunctionValue', 'Time', 'X1', 'X2'});
rast_SA_table = array2table(perf_rast_SA, ...
    'VariableNames', {'Temperature', 'FunctionValue', 'Time', 'X1', 'X2'});
ps_GA_table = array2table(perf_ps_GA, ...
    'VariableNames', {'Crossover', 'FunctionValue', 'Time', 'X1', 'X2'});
ps_SA_table = array2table(perf_ps_SA, ...
    'VariableNames', {'Temperature', 'FunctionValue', 'Time', 'X1', 'X2'});

% Save to .mat file
save('PERFORMANCE_TABLES.mat', 'rast_GA_table', 'rast_SA_table', ...
    'ps_GA_table', 'ps_SA_table');

%% 1.3. Plotting for discussion
close, clc, close all

% Load saved data
load('PERFORMANCE_TABLES.mat');

% --- GA: Efficiency (Time) vs Crossover ---
figure;
plot(rast_GA_table.Crossover, rast_GA_table.Time, 'LineWidth', 1.5);
hold on;
plot(ps_GA_table.Crossover, ps_GA_table.Time, 'LineWidth', 1.5);
xlabel('Crossover');
ylabel('Convergence time');
ylim([0 70])
title('GA - Efficiency');
legend('Rastrigin', 'PS Example', 'Location', 'best');
grid on;
saveas(gcf, 'plots/one/GA_Efficiency.jpg');
close(gcf)

% --- GA: Performance vs Crossover ---
figure;
plot(rast_GA_table.Crossover, rast_GA_table.FunctionValue, 'LineWidth', 1.5);
hold on;
plot(ps_GA_table.Crossover, ps_GA_table.FunctionValue, 'LineWidth', 1.5);
xlabel('Crossover');
ylabel('Minima');
ylim([0 12])
title('GA - Performance');
legend('Rastrigin', 'PS Example', 'Location', 'best');
grid on;
saveas(gcf, 'plots/one/GA_Performance.jpg');
close(gcf)

% --- SA: Efficiency (Time) vs Temperature ---
figure;
plot(rast_SA_table.Temperature, rast_SA_table.Time, 'LineWidth', 1.5);
hold on;
plot(ps_SA_table.Temperature, ps_SA_table.Time, 'LineWidth', 1.5);
xlabel('Temperature');
ylabel('Convergence time');
ylim([0 70])
title('SA - Efficiency');
legend('Rastrigin', 'PS Example', 'Location', 'best');
grid on;
saveas(gcf, 'plots/one/SA_Efficiency.jpg');
close(gcf)

% --- SA: Performance vs Temperature ---
figure;
plot(rast_SA_table.Temperature, rast_SA_table.FunctionValue, 'LineWidth', 1.5); hold on;
plot(ps_SA_table.Temperature, ps_SA_table.FunctionValue, 'LineWidth', 1.5);
xlabel('Temperature');
ylabel('Minima');
ylim([0 12])
title('SA - Performance');
legend('Rastrigin', 'PS Example', 'Location', 'best');
grid on;
saveas(gcf, 'plots/one/SA_Performance.jpg');
close(gcf)

figure;
boxplot([rast_GA_table.FunctionValue; rast_SA_table.FunctionValue], ...
        [repmat({'GA'}, height(rast_GA_table), 1); repmat({'SA'}, height(rast_SA_table), 1)]);
ylabel('Minima');
ylim([0 12])
title('Rastrigin - Performance');
grid on;
saveas(gcf, 'plots/one/Box_Rastrigin_Performance.jpg');
close(gcf)

figure;
boxplot([rast_GA_table.Time; rast_SA_table.Time], ...
        [repmat({'GA'}, height(rast_GA_table), 1); repmat({'SA'}, height(rast_SA_table), 1)]);
ylabel('Convergence time');
ylim([0 70])
title('Rastrigin - Efficiency');
grid on;
saveas(gcf, 'plots/one/Box_Rastrigin_Efficiency.jpg');
close(gcf)

figure;
boxplot([ps_GA_table.FunctionValue; ps_SA_table.FunctionValue], ...
        [repmat({'GA'}, height(ps_GA_table), 1); repmat({'SA'}, height(ps_SA_table), 1)]);
ylabel('Minima');
title('PS Example - Performance');
ylim([0 12])
grid on;
saveas(gcf, 'plots/one/Box_PS_Performance.jpg');
close(gcf)

figure;
boxplot([ps_GA_table.Time; ps_SA_table.Time], ...
        [repmat({'GA'}, height(ps_GA_table), 1); repmat({'SA'}, height(ps_SA_table), 1)]);
ylabel('Convergence time');
ylim([0 70])
title('PS Example - Efficiency');
grid on;
saveas(gcf, 'plots/one/Box_PS_Efficiency.jpg');
close(gcf)

%% 2. PCA on data-set
clear, clc, close all
load fisheriris;

X = meas;     % Use only sepal length & sepal width
true_labels = species;

% Plot original classes
figure;
gscatter(X(:,1), X(:,2), true_labels, 'rgb', 'osd');
xlabel('Sepal Length');
ylabel('Sepal Width');
title('Ground Truth - Sepal Length vs Sepal Width');
grid on;
saveas(gcf, 'plots/two/original_classes_sepal.jpg');
close(gcf)

% Plot original classes
figure;
gscatter(X(:,3), X(:,4), true_labels, 'rgb', 'osd');
xlabel('Petal Length');
ylabel('Petal Width');
title('Ground Truth - Sepal Length vs Sepal Width');
grid on;
saveas(gcf, 'plots/two/original_classes_petal.jpg');
close(gcf)

% Apply PCA
[coeff, score, ~, ~, explained] = pca(meas);

% Convert species to numeric for plotting
species_types = unique(species);
colors = lines(numel(species_types));
figure;
hold on;
for i = 1:numel(species_types)
    idx = strcmp(species, species_types{i});
    scatter(score(idx,1), score(idx,2), 50, colors(i,:), 'filled');
end
xlabel('1st Principal Component');
ylabel('2nd Principal Component');
title('PCA of Iris Dataset');
legend(species_types, 'Location', 'best');
grid on;
saveas(gcf, 'plots/two/Scatterplot_labels.jpg');
close(gcf)

% 2 principal components (first two columns of coeff)
figure
biplot(coeff(:, 1:2), 'Scores',score(:, 1:2), 'VarLabels',...
    {'sepal length', 'sepal width', 'petal length', 'petal width'})
saveas(gcf, 'plots/two/Scores.jpg');
close(gcf)

% The first component mainly captures petal width/length variations, which
% vary the most between species. The second one catches sepal length/width.

% Explained and cumulative variance (single y-axis, cleaner plot)
figure;
hold on;

% Bar plot for explained variance
b = bar(explained, 'FaceColor', [0.2 0.6 0.8]);

% Line plot for cumulative variance
plot(cumsum(explained), '-o', 'LineWidth', 2, 'Color', [0.85 0.33 0.1]);

% Aesthetics
xlabel('Principal Component');
ylabel('Variance (%)');
title('Explained and Cumulative Variance');
ylim([0, 100])
legend({'Explained', 'Cumulative'}, 'Location', 'southeast');
grid on;

saveas(gcf, 'plots/two/variance_explained.jpg');
close(gcf)

%% 3. K-means to identify the optimal number of clusters (unsupervised)
clear; clc; close all;

load fisheriris
X = meas(:, 1:2);     % Use only sepal length & sepal width
true_labels = species;
Y = grp2idx(true_labels);

% Determine optimal number of clusters using silhouette
maxK = 6;
silhouette_avg = zeros(maxK-1,1);
for k = 2:maxK
    idx = kmeans(X, k);
    s = silhouette(X, idx);
    silhouette_avg(k-1) = mean(s);
end

% Plot silhouette scores
figure;
plot(2:maxK, silhouette_avg, '-o', 'LineWidth', 1.5);
xlabel('Number of Clusters (k)');
ylabel('Average Silhouette Score');
title('Silhouette Score for Different k');
grid on;
saveas(gcf, 'plots/three/silhouette.jpg');
close(gcf)

% --- Clustering with optimal k ---
[~, best_k_index] = max(silhouette_avg);
optimal_k = best_k_index + 1;

[idx_opt, C_opt] = kmeans(X, optimal_k);

% Plot clusters with optimal k
figure;
h = gscatter(X(:,1), X(:,2), idx_opt, 'rb', 'os');
hold on;
hc = plot(C_opt(:,1), C_opt(:,2), 'k+', 'MarkerSize', 12, 'LineWidth', 2);
xlabel('Sepal Length');
ylabel('Sepal Width');
title(['K-means with Optimal k = ', num2str(optimal_k)]);
legend([h; hc], {'Cluster 1','Cluster 2','Centroid'}, 'Location', 'best');
grid on;
saveas(gcf, 'plots/three/k_2.jpg');
close(gcf)

% --- Clustering with k = 3 ---
[idx3, C3] = kmeans(X, 3);

figure;
h3 = gscatter(X(:,1), X(:,2), idx3, 'rgb', 'o^s');
hold on;
hc3 = plot(C3(:,1), C3(:,2), 'k+', 'MarkerSize', 12, 'LineWidth', 2);
xlabel('Sepal Length');
ylabel('Sepal Width');
title('K-means with k = 3');
legend([h3; hc3], {'Cluster 1','Cluster 2','Cluster 3','Centroid'}, 'Location', 'best');
grid on;
saveas(gcf, 'plots/three/k_3.jpg');
close(gcf)

% Convert real labels to binary: Setosa = 1, others = 2
Y_binary = ones(size(Y));
Y_binary(Y ~= 1) = 2;

% --- Confusion matrix for k = 2 ---
% Group true labels into 2 categories: Setosa (2) vs Others (1)
Y_binary = double(strcmp(true_labels, 'setosa')) + 1;  % Setosa = 2, Others = 1

% Compute confusion matrix between binary true labels and predicted clusters
cm2 = confusionmat(Y_binary, idx_opt);

% Reorder columns if needed to maximize diagonal alignment (simple heuristic)
if cm2(1,1) + cm2(2,2) < cm2(1,2) + cm2(2,1)
    cm2 = cm2(:, [2 1]);  % swap columns
end

total_samples = sum(cm2(:));
cm2_percent = 100 * cm2 / total_samples;

% Plot heatmap for k = 2 in percent
figure;
heatmap(cm2_percent, ...
    'XData', {'Cluster 1', 'Cluster 2'}, ...
    'YData', {'Others', 'Setosa'}, ...
    'CellLabelColor', 'black', ...
    'CellLabelFormat', '%.1f%%');   % Show as percent
xlabel('Predicted Cluster');
ylabel('True Class');
title('Confusion Matrix (k = 2) â€” Setosa vs Others (Percent)');
saveas(gcf, 'plots/three/confusion_2.jpg');
close(gcf)

% --- Confusion matrix for k = 3 ---
% Compute raw confusion matrix (no alignment yet)
cm_raw = confusionmat(Y, idx3);

% Brute-force alignment using all permutations of cluster indices
perms3 = perms(1:3);  % All 6 permutations of [1 2 3]
num_perm = size(perms3, 1);
best_cm = [];
best_score = -Inf;

for i = 1:num_perm
    perm = perms3(i,:);
    cm_perm = cm_raw(:, perm);          % Reorder predicted clusters
    score = sum(diag(cm_perm));         % Total correct classifications
    if score > best_score
        best_score = score;
        best_cm = cm_perm;
        best_perm = perm;
    end
end

total_samples = sum(best_cm(:));
best_cm = 100 * best_cm / total_samples;

% Plot the aligned confusion matrix
figure;
heatmap(best_cm, ...
    'XData', {'Cluster 2', 'Cluster 1', 'Cluster 3'}, ...
    'YData', {'Setosa', 'Versicolor', 'Virginica'}, ...
    'CellLabelColor', 'black', ...
    'CellLabelFormat', '%.1f%%');   % Show as percent);
xlabel('Predicted Cluster');
ylabel('True Species');
title('Aligned Confusion Matrix (k = 3)');
saveas(gcf, 'plots/three/confusion_3.jpg');
close(gcf)

%% 4. Review of data-driven design papers
clc
disp('Contrasting, i.e. with relevant differences in how methods are used!')